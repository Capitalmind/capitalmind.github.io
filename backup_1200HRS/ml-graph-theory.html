<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Theory Fundamentals - Machine Learning</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #f5f5f5;
            background: #262725;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            color: #f5f5f5;
            margin-bottom: 3rem;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            font-weight: 300;
            color: #cc785c;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 2rem;
        }

        /* Navigation Menu */
        .nav-menu {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin: 2rem 0;
        }

        .nav-menu a {
            color: #cc785c;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border: 1px solid #cc785c;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-menu a:hover {
            background: #cc785c;
            color: #f5f5f5;
        }

        .links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 2rem;
        }

        .links a {
            color: #f5f5f5;
            font-size: 1.5rem;
            transition: transform 0.3s ease;
        }

        .links a:hover {
            transform: scale(1.2);
        }

        /* Back Navigation */
        .back-nav {
            margin-bottom: 2rem;
        }

        .back-nav a {
            color: #cc785c;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border: 1px solid #cc785c;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .back-nav a:hover {
            background: #cc785c;
            color: #f5f5f5;
        }

        /* Content Sections */
        .section {
            background: #262725;
            border-radius: 15px;
            padding: 2.5rem;
            margin-bottom: 3rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 1px solid #3a3a3a;
        }

        .section h2 {
            color: #cc785c;
            font-size: 2rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section h3 {
            color: #cc785c;
            font-size: 1.5rem;
            margin: 2rem 0 1rem 0;
        }

        .section h4 {
            color: #cc785c;
            font-size: 1.2rem;
            margin: 1.5rem 0 0.75rem 0;
        }

        .section p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        .section ul, .section ol {
            margin: 1rem 0 1rem 2rem;
        }

        .section li {
            margin-bottom: 0.5rem;
        }

        /* Interactive Visualizations */
        .visualization-container {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 2rem;
            margin: 2rem 0;
            border-left: 4px solid #cc785c;
        }

        .viz-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .btn {
            background: #cc785c;
            color: #f5f5f5;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #b8704a;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        /* Code Blocks */
        .code-block {
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            border-left: 4px solid #cc785c;
        }

        .code-block .comment {
            color: #7c7c7c;
        }

        .code-block .keyword {
            color: #cc785c;
        }

        .code-block .string {
            color: #98d982;
        }

        /* Algorithm Complexity Boxes */
        .complexity-box {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #cc785c;
        }

        .complexity-box h4 {
            color: #cc785c;
            margin-bottom: 1rem;
        }

        /* Use Case Examples */
        .use-case {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid #cc785c;
        }

        .use-case h5 {
            color: #cc785c;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        /* SVG Styling */
        .node {
            fill: #cc785c;
            stroke: #f5f5f5;
            stroke-width: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            fill: #b8704a;
            transform: scale(1.1);
        }

        .edge {
            stroke: #f5f5f5;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .edge-label {
            fill: #f5f5f5;
            font-size: 12px;
            text-anchor: middle;
        }

        .node-label {
            fill: #f5f5f5;
            font-size: 14px;
            text-anchor: middle;
            font-weight: bold;
            pointer-events: none;
        }

        .visited-node {
            fill: #4ecdc4;
            animation: visited 0.5s ease-in-out;
        }

        .current-node {
            fill: #ff6b6b;
            animation: pulse 1s infinite;
        }

        .path-highlight {
            stroke: #ff6b6b;
            stroke-width: 4px;
            animation: pulse 1.5s infinite;
        }

        @keyframes visited {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Problem Examples */
        .problem-box {
            background: #1a1a1a;
            border: 2px solid #cc785c;
            border-radius: 10px;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .problem-box h4 {
            color: #cc785c;
            margin-bottom: 1rem;
        }

        .problem-solution {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .problem-solution h5 {
            color: #cc785c;
            margin-bottom: 0.5rem;
        }

        /* Table of Contents */
        .toc {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border-left: 4px solid #cc785c;
        }

        .toc h3 {
            color: #cc785c;
            margin-bottom: 1rem;
        }

        .toc ul {
            list-style: none;
            margin: 0;
        }

        .toc li {
            margin-bottom: 0.5rem;
        }

        .toc a {
            color: #f5f5f5;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .toc a:hover {
            color: #cc785c;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 1rem;
            }
            
            .section {
                padding: 1.5rem;
            }

            .nav-menu {
                gap: 0.5rem;
            }

            .nav-menu a {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }

            .viz-controls {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="back-nav">
            <a href="machine-learning.html">
                <i class="fas fa-arrow-left"></i> Back to ML Topics
            </a>
        </div>

        <header class="header">
            <h1><i class="fas fa-project-diagram"></i> Graph Theory Fundamentals</h1>
            <p class="subtitle">The Mathematical Foundation of Networks, Neural Systems & Data Relationships</p>
            
            <div class="links">
                <a href="https://github.com/Capitalmind" title="GitHub" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i></a>
                <a href="mailto:tech@skynode.one" title="Email"><i class="fas fa-envelope"></i></a>
                <a href="https://x.com/Alt_Samman" title="X (Twitter)" target="_blank" rel="noopener noreferrer"><i class="fab fa-x-twitter"></i></a>
            </div>
        </header>

        <!-- Table of Contents -->
        <div class="toc">
            <h3><i class="fas fa-list"></i> What You'll Learn</h3>
            <ul>
                <li><a href="#introduction">• Introduction to Graph Theory</a></li>
                <li><a href="#types">• Graph Types & Representations</a></li>
                <li><a href="#traversal">• Traversal Algorithms (BFS, DFS)</a></li>
                <li><a href="#pathfinding">• Pathfinding & Shortest Paths</a></li>
                <li><a href="#applications">• Machine Learning Applications</a></li>
                <li><a href="#problems">• Real-World Problems & Solutions</a></li>
                <li><a href="#implementation">• Complete Python Implementations</a></li>
            </ul>
        </div>

        <!-- Introduction Section -->
        <div class="section" id="introduction">
            <h2><i class="fas fa-graduation-cap"></i> What is Graph Theory?</h2>
            <p>
                Graph theory is the mathematical study of networks—collections of objects (vertices) connected by relationships (edges). While seemingly abstract, graphs are everywhere in machine learning and computer science, from the neural networks that power AI to the social networks that connect billions of people.
            </p>
            
            <p>
                In machine learning, understanding graphs means understanding how data flows through neural networks, how recommendation systems find connections between users and items, and how search algorithms navigate complex problem spaces.
            </p>

            <div class="use-case">
                <h5>Real-World Example: Your Brain</h5>
                <p>
                    Your brain is a graph with 86 billion neurons (vertices) connected by trillions of synapses (edges). Artificial neural networks mirror this structure, using graph theory principles to process information and learn patterns.
                </p>
            </div>

            <h3>Mathematical Definition</h3>
            <p>
                A graph G = (V, E) consists of:
            </p>
            <ul>
                <li><strong>V</strong>: A set of vertices (nodes) representing entities</li>
                <li><strong>E</strong>: A set of edges connecting pairs of vertices</li>
            </ul>

            <div class="code-block">
<span class="comment"># Simple graph representation</span>
<span class="keyword">class</span> Graph:
    <span class="keyword">def</span> __init__(self, directed=False):
        self.directed = directed
        self.vertices = set()
        self.edges = []
    
    <span class="keyword">def</span> add_vertex(self, vertex):
        self.vertices.add(vertex)
    
    <span class="keyword">def</span> add_edge(self, vertex1, vertex2, weight=1):
        self.add_vertex(vertex1)
        self.add_vertex(vertex2)
        self.edges.append((vertex1, vertex2, weight))
            </div>
        </div>

        <!-- Graph Types Section -->
        <div class="section" id="types">
            <h2><i class="fas fa-sitemap"></i> Graph Types & Representations</h2>
            
            <h3>Fundamental Graph Types</h3>
            
            <div class="visualization-container">
                <h4>Interactive Graph Types Comparison</h4>
                <div class="viz-controls">
                    <button class="btn" onclick="showUndirected()">Undirected Graph</button>
                    <button class="btn" onclick="showDirected()">Directed Graph</button>
                    <button class="btn" onclick="showWeighted()">Weighted Graph</button>
                    <button class="btn" onclick="showComplete()">Complete Graph</button>
                </div>
                
                <div style="text-align: center;">
                    <svg width="500" height="300" id="graph-types-viz">
                        <!-- Default: Undirected Graph -->
                        <g id="undirected-graph">
                            <line x1="100" y1="100" x2="200" y2="100" class="edge"/>
                            <line x1="200" y1="100" x2="300" y2="100" class="edge"/>
                            <line x1="100" y1="100" x2="150" y2="200" class="edge"/>
                            <line x1="200" y1="100" x2="250" y2="200" class="edge"/>
                            <line x1="150" y1="200" x2="250" y2="200" class="edge"/>
                            <line x1="300" y1="100" x2="250" y2="200" class="edge"/>
                            
                            <circle cx="100" cy="100" r="15" class="node"/>
                            <circle cx="200" cy="100" r="15" class="node"/>
                            <circle cx="300" cy="100" r="15" class="node"/>
                            <circle cx="150" cy="200" r="15" class="node"/>
                            <circle cx="250" cy="200" r="15" class="node"/>
                            
                            <text x="100" y="105" class="node-label">A</text>
                            <text x="200" y="105" class="node-label">B</text>
                            <text x="300" y="105" class="node-label">C</text>
                            <text x="150" y="205" class="node-label">D</text>
                            <text x="250" y="205" class="node-label">E</text>
                        </g>
                        
                        <!-- Directed Graph (hidden initially) -->
                        <g id="directed-graph" style="display: none;">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                        refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#f5f5f5"/>
                                </marker>
                            </defs>
                            <!-- Directed edges with arrows -->
                        </g>
                        
                        <!-- Other graph types will be added similarly -->
                    </svg>
                </div>
                
                <div id="graph-explanation" style="margin-top: 1rem; padding: 1rem; background: #2a2a2a; border-radius: 5px;">
                    <strong>Undirected Graph:</strong> Edges have no direction. Represents symmetric relationships like friendship networks or physical connections.
                </div>
            </div>

            <h4>1. Undirected Graphs</h4>
            <p>
                Edges represent symmetric relationships. If A connects to B, then B connects to A. Common in social networks (mutual friendships), molecular structures, and transportation networks.
            </p>

            <div class="use-case">
                <h5>ML Application: Collaborative Filtering</h5>
                <p>
                    In recommendation systems, undirected graphs can represent user similarity. If users A and B have similar preferences, there's an undirected edge between them, enabling collaborative filtering algorithms.
                </p>
            </div>

            <h4>2. Directed Graphs (Digraphs)</h4>
            <p>
                Edges have direction, representing asymmetric relationships. Web pages linking to other pages, neural network connections, and dependency graphs are directed.
            </p>

            <div class="code-block">
<span class="comment"># Directed graph for neural network representation</span>
<span class="keyword">class</span> NeuralNetworkGraph:
    <span class="keyword">def</span> __init__(self):
        self.layers = []
        self.connections = {}  <span class="comment"># source_neuron -> [(target_neuron, weight)]</span>
    
    <span class="keyword">def</span> add_connection(self, source, target, weight):
        <span class="keyword">if</span> source <span class="keyword">not in</span> self.connections:
            self.connections[source] = []
        self.connections[source].append((target, weight))
    
    <span class="keyword">def</span> forward_pass(self, input_values):
        <span class="comment"># Traverse graph in topological order</span>
        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:
            <span class="keyword">for</span> neuron <span class="keyword">in</span> layer:
                neuron.compute_output(input_values)
            </div>

            <h4>3. Weighted Graphs</h4>
            <p>
                Edges have associated weights representing costs, distances, similarities, or connection strengths. Essential for pathfinding, neural networks, and optimization problems.
            </p>

            <h3>Graph Representation Methods</h3>
            
            <h4>Adjacency Matrix vs Adjacency List</h4>
            <p>
                Choosing the right representation affects performance and memory usage significantly.
            </p>

            <div class="code-block">
<span class="comment"># Adjacency Matrix - Fast lookups, more memory</span>
<span class="keyword">import</span> numpy <span class="keyword">as</span> np

<span class="keyword">class</span> AdjacencyMatrix:
    <span class="keyword">def</span> __init__(self, num_vertices):
        self.matrix = np.zeros((num_vertices, num_vertices))
        self.vertex_map = {}
        self.next_index = 0
    
    <span class="keyword">def</span> add_edge(self, v1, v2, weight=1):
        i, j = self._get_indices(v1, v2)
        self.matrix[i][j] = weight
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            self.matrix[j][i] = weight
    
    <span class="keyword">def</span> has_edge(self, v1, v2):
        i, j = self._get_indices(v1, v2)
        <span class="keyword">return</span> self.matrix[i][j] != 0  <span class="comment"># O(1) lookup!</span>

<span class="comment"># Adjacency List - Memory efficient, good for iteration</span>
<span class="keyword">class</span> AdjacencyList:
    <span class="keyword">def</span> __init__(self):
        self.graph = defaultdict(list)
    
    <span class="keyword">def</span> add_edge(self, v1, v2, weight=1):
        self.graph[v1].append((v2, weight))
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            self.graph[v2].append((v1, weight))
    
    <span class="keyword">def</span> get_neighbors(self, vertex):
        <span class="keyword">return</span> self.graph[vertex]  <span class="comment"># Easy iteration</span>
            </div>

            <div class="complexity-box">
                <h4>Representation Complexity Comparison</h4>
                <table style="width: 100%; color: #f5f5f5;">
                    <tr style="border-bottom: 1px solid #cc785c;">
                        <th>Operation</th>
                        <th>Adjacency Matrix</th>
                        <th>Adjacency List</th>
                    </tr>
                    <tr>
                        <td>Space</td>
                        <td>O(V²)</td>
                        <td>O(V + E)</td>
                    </tr>
                    <tr>
                        <td>Add Edge</td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>Check Edge</td>
                        <td>O(1)</td>
                        <td>O(degree)</td>
                    </tr>
                    <tr>
                        <td>Iterate Neighbors</td>
                        <td>O(V)</td>
                        <td>O(degree)</td>
                    </tr>
                </table>
                <p style="margin-top: 1rem;"><strong>Rule of thumb:</strong> Use matrix for dense graphs (many edges), list for sparse graphs (few edges).</p>
            </div>
        </div>

        <!-- Traversal Algorithms Section -->
        <div class="section" id="traversal">
            <h2><i class="fas fa-route"></i> Graph Traversal Algorithms</h2>
            
            <p>
                Traversal algorithms systematically visit every vertex in a graph. They're fundamental to search, pathfinding, and many machine learning algorithms.
            </p>

            <div class="visualization-container">
                <h4>Interactive Traversal Demonstration</h4>
                <div class="viz-controls">
                    <button class="btn" onclick="animateBFS()" id="bfs-btn">Run BFS</button>
                    <button class="btn" onclick="animateDFS()" id="dfs-btn">Run DFS</button>
                    <button class="btn" onclick="resetTraversal()">Reset</button>
                    <button class="btn" onclick="stepMode = !stepMode" id="step-btn">Step Mode: OFF</button>
                </div>
                
                <div style="text-align: center;">
                    <svg width="600" height="400" id="traversal-viz">
                        <!-- Tree structure for clear demonstration -->
                        <!-- Level 1 - Root -->
                        <line x1="300" y1="50" x2="200" y2="120" class="edge" id="edge-1-2"/>
                        <line x1="300" y1="50" x2="400" y2="120" class="edge" id="edge-1-3"/>
                        
                        <!-- Level 2 -->
                        <line x1="200" y1="120" x2="150" y2="190" class="edge" id="edge-2-4"/>
                        <line x1="200" y1="120" x2="250" y2="190" class="edge" id="edge-2-5"/>
                        <line x1="400" y1="120" x2="350" y2="190" class="edge" id="edge-3-6"/>
                        <line x1="400" y1="120" x2="450" y2="190" class="edge" id="edge-3-7"/>
                        
                        <!-- Level 3 -->
                        <line x1="150" y1="190" x2="100" y2="260" class="edge" id="edge-4-8"/>
                        <line x1="150" y1="190" x2="200" y2="260" class="edge" id="edge-4-9"/>
                        <line x1="250" y1="190" x2="300" y2="260" class="edge" id="edge-5-10"/>
                        
                        <!-- Nodes -->
                        <circle cx="300" cy="50" r="20" class="node" id="node-1"/>
                        <circle cx="200" cy="120" r="20" class="node" id="node-2"/>
                        <circle cx="400" cy="120" r="20" class="node" id="node-3"/>
                        <circle cx="150" cy="190" r="20" class="node" id="node-4"/>
                        <circle cx="250" cy="190" r="20" class="node" id="node-5"/>
                        <circle cx="350" cy="190" r="20" class="node" id="node-6"/>
                        <circle cx="450" cy="190" r="20" class="node" id="node-7"/>
                        <circle cx="100" cy="260" r="20" class="node" id="node-8"/>
                        <circle cx="200" cy="260" r="20" class="node" id="node-9"/>
                        <circle cx="300" cy="260" r="20" class="node" id="node-10"/>
                        
                        <!-- Labels -->
                        <text x="300" y="55" class="node-label">1</text>
                        <text x="200" y="125" class="node-label">2</text>
                        <text x="400" y="125" class="node-label">3</text>
                        <text x="150" y="195" class="node-label">4</text>
                        <text x="250" y="195" class="node-label">5</text>
                        <text x="350" y="195" class="node-label">6</text>
                        <text x="450" y="195" class="node-label">7</text>
                        <text x="100" y="265" class="node-label">8</text>
                        <text x="200" y="265" class="node-label">9</text>
                        <text x="300" y="265" class="node-label">10</text>
                    </svg>
                </div>
                
                <div id="traversal-info" style="margin-top: 1rem; padding: 1rem; background: #2a2a2a; border-radius: 5px;">
                    <div><strong>Algorithm:</strong> <span id="current-algorithm">Choose an algorithm above</span></div>
                    <div><strong>Order:</strong> <span id="visit-order">-</span></div>
                    <div><strong>Data Structure:</strong> <span id="data-structure">-</span></div>
                    <div><strong>Current Step:</strong> <span id="current-step">Ready to start</span></div>
                </div>
            </div>

            <h3>Breadth-First Search (BFS)</h3>
            <p>
                BFS explores neighbors level by level, like ripples spreading in a pond. It uses a queue (first-in, first-out) and guarantees finding the shortest path in unweighted graphs.
            </p>

            <div class="code-block">
<span class="keyword">from</span> collections <span class="keyword">import</span> deque

<span class="keyword">def</span> bfs(graph, start_vertex):
    <span class="string">"""
    Breadth-First Search implementation
    Returns: (visited_order, distances_from_start)
    """</span>
    visited = set()
    queue = deque([start_vertex])
    visit_order = []
    distances = {start_vertex: 0}
    
    <span class="keyword">while</span> queue:
        vertex = queue.popleft()  <span class="comment"># FIFO - queue behavior</span>
        
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            visited.add(vertex)
            visit_order.append(vertex)
            
            <span class="comment"># Add all unvisited neighbors to queue</span>
            <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph.get_neighbors(vertex):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    queue.append(neighbor)
                    <span class="keyword">if</span> neighbor <span class="keyword">not in</span> distances:
                        distances[neighbor] = distances[vertex] + 1
    
    <span class="keyword">return</span> visit_order, distances

<span class="comment"># BFS for shortest path in unweighted graph</span>
<span class="keyword">def</span> bfs_shortest_path(graph, start, goal):
    queue = deque([(start, [start])])
    visited = set()
    
    <span class="keyword">while</span> queue:
        vertex, path = queue.popleft()
        
        <span class="keyword">if</span> vertex == goal:
            <span class="keyword">return</span> path
        
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            visited.add(vertex)
            
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.get_neighbors(vertex):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    queue.append((neighbor, path + [neighbor]))
    
    <span class="keyword">return</span> None  <span class="comment"># No path found</span>
            </div>

            <h3>Depth-First Search (DFS)</h3>
            <p>
                DFS explores as deep as possible before backtracking. It uses a stack (last-in, first-out) and is essential for topological sorting, cycle detection, and maze solving.
            </p>

            <div class="code-block">
<span class="keyword">def</span> dfs_recursive(graph, start_vertex, visited=None):
    <span class="string">"""
    Recursive DFS implementation
    """</span>
    <span class="keyword">if</span> visited <span class="keyword">is</span> None:
        visited = set()
    
    visited.add(start_vertex)
    visit_order = [start_vertex]
    
    <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph.get_neighbors(start_vertex):
        <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
            visit_order.extend(dfs_recursive(graph, neighbor, visited))
    
    <span class="keyword">return</span> visit_order

<span class="keyword">def</span> dfs_iterative(graph, start_vertex):
    <span class="string">"""
    Iterative DFS using explicit stack
    Better for deep graphs (avoids recursion limit)
    """</span>
    visited = set()
    stack = [start_vertex]
    visit_order = []
    
    <span class="keyword">while</span> stack:
        vertex = stack.pop()  <span class="comment"># LIFO - stack behavior</span>
        
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
            visited.add(vertex)
            visit_order.append(vertex)
            
            <span class="comment"># Add neighbors to stack (reverse order for consistent traversal)</span>
            neighbors = list(graph.get_neighbors(vertex))
            <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> reversed(neighbors):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    stack.append(neighbor)
    
    <span class="keyword">return</span> visit_order

<span class="comment"># DFS for cycle detection in directed graphs</span>
<span class="keyword">def</span> has_cycle_dfs(graph):
    white = set(graph.vertices)  <span class="comment"># Unvisited</span>
    gray = set()                 <span class="comment"># Currently processing</span>
    black = set()                <span class="comment"># Fully processed</span>
    
    <span class="keyword">def</span> visit(vertex):
        <span class="keyword">if</span> vertex <span class="keyword">in</span> gray:
            <span class="keyword">return</span> True  <span class="comment"># Back edge found - cycle detected!</span>
        
        <span class="keyword">if</span> vertex <span class="keyword">in</span> black:
            <span class="keyword">return</span> False
        
        white.discard(vertex)
        gray.add(vertex)
        
        <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.get_neighbors(vertex):
            <span class="keyword">if</span> visit(neighbor):
                <span class="keyword">return</span> True
        
        gray.discard(vertex)
        black.add(vertex)
        <span class="keyword">return</span> False
    
    <span class="keyword">return</span> any(visit(v) <span class="keyword">for</span> v <span class="keyword">in</span> list(white))
            </div>

            <div class="complexity-box">
                <h4>BFS vs DFS Comparison</h4>
                <table style="width: 100%; color: #f5f5f5;">
                    <tr style="border-bottom: 1px solid #cc785c;">
                        <th>Aspect</th>
                        <th>BFS</th>
                        <th>DFS</th>
                    </tr>
                    <tr>
                        <td>Data Structure</td>
                        <td>Queue (FIFO)</td>
                        <td>Stack (LIFO)</td>
                    </tr>
                    <tr>
                        <td>Time Complexity</td>
                        <td>O(V + E)</td>
                        <td>O(V + E)</td>
                    </tr>
                    <tr>
                        <td>Space Complexity</td>
                        <td>O(V)</td>
                        <td>O(V)</td>
                    </tr>
                    <tr>
                        <td>Shortest Path</td>
                        <td>✅ Guarantees shortest</td>
                        <td>❌ No guarantee</td>
                    </tr>
                    <tr>
                        <td>Memory Usage</td>
                        <td>Higher (stores all level nodes)</td>
                        <td>Lower (only path nodes)</td>
                    </tr>
                    <tr>
                        <td>Use Cases</td>
                        <td>Shortest path, level-order</td>
                        <td>Topological sort, cycles</td>
                    </tr>
                </table>
            </div>

            <div class="use-case">
                <h5>ML Application: Neural Network Computation</h5>
                <p>
                    <strong>Forward Pass:</strong> Uses topological ordering (DFS-based) to ensure each neuron computes after its inputs are ready.<br>
                    <strong>Backpropagation:</strong> Reverse topological order to propagate gradients from output to input layers.
                </p>
            </div>
        </div>

        <!-- Pathfinding Section -->
        <div class="section" id="pathfinding">
            <h2><i class="fas fa-map-marked-alt"></i> Pathfinding & Shortest Path Algorithms</h2>
            
            <p>
                Finding optimal paths through graphs is crucial in machine learning for optimization, neural network training, and decision-making systems.
            </p>

            <div class="visualization-container">
                <h4>Dijkstra's Algorithm Interactive Demo</h4>
                <div class="viz-controls">
                    <button class="btn" onclick="runDijkstra()" id="dijkstra-btn">Run Dijkstra's</button>
                    <button class="btn" onclick="resetDijkstra()">Reset</button>
                    <button class="btn" onclick="stepDijkstra()" id="step-dijkstra" disabled>Next Step</button>
                </div>
                
                <div style="text-align: center;">
                    <svg width="700" height="400" id="dijkstra-viz">
                        <!-- Weighted graph for pathfinding -->
                        <line x1="80" y1="150" x2="180" y2="80" class="edge" id="d-edge-sa"/>
                        <line x1="80" y1="150" x2="180" y2="220" class="edge" id="d-edge-sb"/>
                        <line x1="180" y1="80" x2="300" y2="80" class="edge" id="d-edge-ac"/>
                        <line x1="180" y1="80" x2="300" y2="200" class="edge" id="d-edge-ad"/>
                        <line x1="180" y1="220" x2="300" y2="200" class="edge" id="d-edge-bd"/>
                        <line x1="300" y1="80" x2="420" y2="140" class="edge" id="d-edge-ce"/>
                        <line x1="300" y1="200" x2="420" y2="140" class="edge" id="d-edge-de"/>
                        <line x1="180" y1="220" x2="420" y2="240" class="edge" id="d-edge-bf"/>
                        <line x1="300" y1="200" x2="420" y2="240" class="edge" id="d-edge-df"/>
                        <line x1="420" y1="140" x2="550" y2="140" class="edge" id="d-edge-et"/>
                        <line x1="420" y1="240" x2="550" y2="140" class="edge" id="d-edge-ft"/>
                        
                        <!-- Edge weights -->
                        <text x="130" y="110" class="edge-label">4</text>
                        <text x="130" y="190" class="edge-label">2</text>
                        <text x="240" y="70" class="edge-label">3</text>
                        <text x="240" y="135" class="edge-label">5</text>
                        <text x="240" y="215" class="edge-label">1</text>
                        <text x="360" y="105" class="edge-label">2</text>
                        <text x="360" y="175" class="edge-label">3</text>
                        <text x="300" y="235" class="edge-label">6</text>
                        <text x="360" y="225" class="edge-label">1</text>
                        <text x="485" y="130" class="edge-label">2</text>
                        <text x="485" y="195" class="edge-label">4</text>
                        
                        <!-- Nodes -->
                        <circle cx="80" cy="150" r="25" class="node" id="d-node-s"/>
                        <circle cx="180" cy="80" r="25" class="node" id="d-node-a"/>
                        <circle cx="180" cy="220" r="25" class="node" id="d-node-b"/>
                        <circle cx="300" cy="80" r="25" class="node" id="d-node-c"/>
                        <circle cx="300" cy="200" r="25" class="node" id="d-node-d"/>
                        <circle cx="420" cy="140" r="25" class="node" id="d-node-e"/>
                        <circle cx="420" cy="240" r="25" class="node" id="d-node-f"/>
                        <circle cx="550" cy="140" r="25" class="node" id="d-node-t"/>
                        
                        <!-- Node labels -->
                        <text x="80" y="155" class="node-label">S</text>
                        <text x="180" y="85" class="node-label">A</text>
                        <text x="180" y="225" class="node-label">B</text>
                        <text x="300" y="85" class="node-label">C</text>
                        <text x="300" y="205" class="node-label">D</text>
                        <text x="420" y="145" class="node-label">E</text>
                        <text x="420" y="245" class="node-label">F</text>
                        <text x="550" y="145" class="node-label">T</text>
                        
                        <!-- Distance labels -->
                        <text x="60" y="130" class="edge-label" id="dist-s" style="font-weight: bold;">0</text>
                        <text x="160" y="60" class="edge-label" id="dist-a" style="font-weight: bold;">∞</text>
                        <text x="160" y="240" class="edge-label" id="dist-b" style="font-weight: bold;">∞</text>
                        <text x="280" y="60" class="edge-label" id="dist-c" style="font-weight: bold;">∞</text>
                        <text x="280" y="220" class="edge-label" id="dist-d" style="font-weight: bold;">∞</text>
                        <text x="400" y="120" class="edge-label" id="dist-e" style="font-weight: bold;">∞</text>
                        <text x="400" y="260" class="edge-label" id="dist-f" style="font-weight: bold;">∞</text>
                        <text x="530" y="120" class="edge-label" id="dist-t" style="font-weight: bold;">∞</text>
                    </svg>
                </div>
                
                <div id="dijkstra-info" style="margin-top: 1rem; padding: 1rem; background: #2a2a2a; border-radius: 5px;">
                    <div><strong>Current Node:</strong> <span id="current-node">S (Start)</span></div>
                    <div><strong>Priority Queue:</strong> <span id="priority-queue">[(0, S)]</span></div>
                    <div><strong>Shortest Path to T:</strong> <span id="shortest-path">Not found yet</span></div>
                    <div><strong>Total Distance:</strong> <span id="total-distance">-</span></div>
                </div>
            </div>

            <h3>Dijkstra's Algorithm</h3>
            <p>
                Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights. It's the foundation of GPS navigation and network routing.
            </p>

            <div class="code-block">
<span class="keyword">import</span> heapq

<span class="keyword">def</span> dijkstra(graph, start_vertex):
    <span class="string">"""
    Dijkstra's shortest path algorithm
    Returns: (distances, previous_vertices)
    """</span>
    distances = {vertex: float('infinity') <span class="keyword">for</span> vertex <span class="keyword">in</span> graph.vertices}
    distances[start_vertex] = 0
    previous = {}
    
    <span class="comment"># Priority queue: (distance, vertex)</span>
    priority_queue = [(0, start_vertex)]
    visited = set()
    
    <span class="keyword">while</span> priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        <span class="keyword">if</span> current_vertex <span class="keyword">in</span> visited:
            <span class="keyword">continue</span>
        
        visited.add(current_vertex)
        
        <span class="comment"># Check all neighbors</span>
        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph.get_neighbors(current_vertex):
            distance = current_distance + weight
            
            <span class="comment"># Found shorter path to neighbor</span>
            <span class="keyword">if</span> distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))
    
    <span class="keyword">return</span> distances, previous

<span class="keyword">def</span> reconstruct_path(previous, start, end):
    <span class="string">"""Reconstruct shortest path from previous vertices"""</span>
    path = []
    current = end
    
    <span class="keyword">while</span> current <span class="keyword">is not</span> None:
        path.append(current)
        current = previous.get(current)
    
    path.reverse()
    <span class="keyword">return</span> path <span class="keyword">if</span> path[0] == start <span class="keyword">else</span> None

<span class="comment"># Example usage</span>
distances, previous = dijkstra(graph, 'S')
shortest_path = reconstruct_path(previous, 'S', 'T')
print(f<span class="string">"Shortest path: {shortest_path}"</span>)
print(f<span class="string">"Distance: {distances['T']}"</span>)
            </div>

            <h3>A* Search Algorithm</h3>
            <p>
                A* combines Dijkstra's accuracy with heuristic guidance, making it faster for pathfinding when you know the goal location. It's widely used in game AI and robotics.
            </p>

            <div class="code-block">
<span class="keyword">def</span> a_star_search(graph, start, goal, heuristic_func):
    <span class="string">"""
    A* pathfinding algorithm
    heuristic_func(node, goal) should return estimated cost to goal
    """</span>
    open_set = [(0, start)]
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic_func(start, goal)}
    
    <span class="keyword">while</span> open_set:
        current = heapq.heappop(open_set)[1]
        
        <span class="keyword">if</span> current == goal:
            <span class="keyword">return</span> reconstruct_path(came_from, start, goal)
        
        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph.get_neighbors(current):
            tentative_g_score = g_score[current] + weight
            
            <span class="keyword">if</span> neighbor <span class="keyword">not in</span> g_score <span class="keyword">or</span> tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + heuristic_func(neighbor, goal)
                
                <span class="keyword">if</span> (f_score[neighbor], neighbor) <span class="keyword">not in</span> open_set:
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
    
    <span class="keyword">return</span> None  <span class="comment"># No path found</span>

<span class="comment"># Manhattan distance heuristic for grid-based pathfinding</span>
<span class="keyword">def</span> manhattan_distance(node1, node2):
    x1, y1 = node1
    x2, y2 = node2
    <span class="keyword">return</span> abs(x1 - x2) + abs(y1 - y2)

<span class="comment"># Euclidean distance for continuous spaces</span>
<span class="keyword">def</span> euclidean_distance(node1, node2):
    x1, y1 = node1
    x2, y2 = node2
    <span class="keyword">return</span> ((x1 - x2)**2 + (y1 - y2)**2)**0.5
            </div>

            <div class="complexity-box">
                <h4>Pathfinding Algorithm Comparison</h4>
                <table style="width: 100%; color: #f5f5f5;">
                    <tr style="border-bottom: 1px solid #cc785c;">
                        <th>Algorithm</th>
                        <th>Time Complexity</th>
                        <th>Space Complexity</th>
                        <th>Optimal</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td>BFS</td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>✅ Unweighted only</td>
                        <td>Unweighted shortest path</td>
                    </tr>
                    <tr>
                        <td>Dijkstra's</td>
                        <td>O((V + E) log V)</td>
                        <td>O(V)</td>
                        <td>✅ Non-negative weights</td>
                        <td>Weighted shortest path</td>
                    </tr>
                    <tr>
                        <td>A*</td>
                        <td>O(b^d)</td>
                        <td>O(b^d)</td>
                        <td>✅ With admissible heuristic</td>
                        <td>Goal-directed pathfinding</td>
                    </tr>
                    <tr>
                        <td>Bellman-Ford</td>
                        <td>O(VE)</td>
                        <td>O(V)</td>
                        <td>✅ Handles negative weights</td>
                        <td>Negative weight detection</td>
                    </tr>
                </table>
            </div>

            <div class="use-case">
                <h5>ML Application: Neural Architecture Search</h5>
                <p>
                    Modern AutoML systems use graph search algorithms to find optimal neural network architectures. Each node represents a layer type, edges represent connections, and the goal is finding the architecture that minimizes validation loss.
                </p>
            </div>
        </div>

        <!-- Applications Section -->
        <div class="section" id="applications">
            <h2><i class="fas fa-brain"></i> Machine Learning Applications</h2>
            
            <h3>Neural Networks as Computational Graphs</h3>
            <p>
                Every neural network is a directed acyclic graph (DAG) where neurons are vertices and weighted connections are edges. Understanding this graph structure is crucial for implementing backpropagation and designing new architectures.
            </p>

            <div class="visualization-container">
                <h4>Neural Network Graph Structure</h4>
                <div style="text-align: center;">
                    <svg width="700" height="350" id="neural-network-viz">
                        <!-- Input Layer -->
                        <circle cx="80" cy="100" r="15" class="node"/>
                        <circle cx="80" cy="150" r="15" class="node"/>
                        <circle cx="80" cy="200" r="15" class="node"/>
                        <circle cx="80" cy="250" r="15" class="node"/>
                        
                        <!-- Hidden Layer 1 -->
                        <circle cx="220" cy="80" r="15" class="node"/>
                        <circle cx="220" cy="120" r="15" class="node"/>
                        <circle cx="220" cy="160" r="15" class="node"/>
                        <circle cx="220" cy="200" r="15" class="node"/>
                        <circle cx="220" cy="240" r="15" class="node"/>
                        <circle cx="220" cy="280" r="15" class="node"/>
                        
                        <!-- Hidden Layer 2 -->
                        <circle cx="360" cy="120" r="15" class="node"/>
                        <circle cx="360" cy="160" r="15" class="node"/>
                        <circle cx="360" cy="200" r="15" class="node"/>
                        <circle cx="360" cy="240" r="15" class="node"/>
                        
                        <!-- Output Layer -->
                        <circle cx="500" cy="150" r="15" class="node"/>
                        <circle cx="500" cy="200" r="15" class="node"/>
                        
                        <!-- Connections (subset for clarity) -->
                        <!-- Input to Hidden 1 -->
                        <line x1="95" y1="100" x2="205" y2="80" class="edge" opacity="0.4"/>
                        <line x1="95" y1="100" x2="205" y2="120" class="edge" opacity="0.4"/>
                        <line x1="95" y1="150" x2="205" y2="120" class="edge" opacity="0.4"/>
                        <line x1="95" y1="150" x2="205" y2="160" class="edge" opacity="0.4"/>
                        <line x1="95" y1="200" x2="205" y2="160" class="edge" opacity="0.4"/>
                        <line x1="95" y1="200" x2="205" y2="200" class="edge" opacity="0.4"/>
                        <line x1="95" y1="250" x2="205" y2="240" class="edge" opacity="0.4"/>
                        <line x1="95" y1="250" x2="205" y2="280" class="edge" opacity="0.4"/>
                        
                        <!-- Hidden 1 to Hidden 2 -->
                        <line x1="235" y1="80" x2="345" y2="120" class="edge" opacity="0.4"/>
                        <line x1="235" y1="120" x2="345" y2="120" class="edge" opacity="0.4"/>
                        <line x1="235" y1="160" x2="345" y2="160" class="edge" opacity="0.4"/>
                        <line x1="235" y1="200" x2="345" y2="200" class="edge" opacity="0.4"/>
                        <line x1="235" y1="240" x2="345" y2="240" class="edge" opacity="0.4"/>
                        
                        <!-- Hidden 2 to Output -->
                        <line x1="375" y1="120" x2="485" y2="150" class="edge" opacity="0.4"/>
                        <line x1="375" y1="160" x2="485" y2="150" class="edge" opacity="0.4"/>
                        <line x1="375" y1="200" x2="485" y2="200" class="edge" opacity="0.4"/>
                        <line x1="375" y1="240" x2="485" y2="200" class="edge" opacity="0.4"/>
                        
                        <!-- Layer Labels -->
                        <text x="80" y="40" class="node-label" style="font-size: 16px;">Input Layer</text>
                        <text x="220" y="40" class="node-label" style="font-size: 16px;">Hidden Layer 1</text>
                        <text x="360" y="40" class="node-label" style="font-size: 16px;">Hidden Layer 2</text>
                        <text x="500" y="40" class="node-label" style="font-size: 16px;">Output Layer</text>
                        
                        <!-- Input labels -->
                        <text x="50" y="105" class="node-label" style="font-size: 12px;">x₁</text>
                        <text x="50" y="155" class="node-label" style="font-size: 12px;">x₂</text>
                        <text x="50" y="205" class="node-label" style="font-size: 12px;">x₃</text>
                        <text x="50" y="255" class="node-label" style="font-size: 12px;">x₄</text>
                        
                        <!-- Output labels -->
                        <text x="530" y="155" class="node-label" style="font-size: 12px;">ŷ₁</text>
                        <text x="530" y="205" class="node-label" style="font-size: 12px;">ŷ₂</text>
                    </svg>
                </div>
                
                <div style="margin-top: 1rem; padding: 1rem; background: #2a2a2a; border-radius: 5px;">
                    <h5 style="color: #cc785c; margin-bottom: 0.5rem;">Graph Properties:</h5>
                    <ul>
                        <li><strong>Type:</strong> Directed Acyclic Graph (DAG)</li>
                        <li><strong>Vertices:</strong> Neurons (computational units)</li>
                        <li><strong>Edges:</strong> Weighted connections (learnable parameters)</li>
                        <li><strong>Forward Pass:</strong> Topological traversal (left to right)</li>
                        <li><strong>Backpropagation:</strong> Reverse topological order (right to left)</li>
                    </ul>
                </div>
            </div>

            <div class="code-block">
<span class="keyword">class</span> NeuralNetworkGraph:
    <span class="string">"""Neural network implemented as computational graph"""</span>
    
    <span class="keyword">def</span> __init__(self):
        self.nodes = {}           <span class="comment"># node_id -> computation function</span>
        self.edges = {}           <span class="comment"># (from, to) -> weight</span>
        self.topology_order = []  <span class="comment"># For forward/backward passes</span>
    
    <span class="keyword">def</span> add_layer(self, layer_id, size, activation='relu'):
        <span class="comment"># Add neurons as graph nodes</span>
        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):
            node_id = f<span class="string">"{layer_id}_{i}"</span>
            self.nodes[node_id] = {
                <span class="string">'type'</span>: <span class="string">'neuron'</span>,
                <span class="string">'activation'</span>: activation,
                <span class="string">'value'</span>: 0.0,
                <span class="string">'gradient'</span>: 0.0
            }
    
    <span class="keyword">def</span> connect_layers(self, from_layer, to_layer):
        <span class="comment"># Create edges between all neurons in adjacent layers</span>
        from_nodes = [n <span class="keyword">for</span> n <span class="keyword">in</span> self.nodes <span class="keyword">if</span> n.startswith(from_layer)]
        to_nodes = [n <span class="keyword">for</span> n <span class="keyword">in</span> self.nodes <span class="keyword">if</span> n.startswith(to_layer)]
        
        <span class="keyword">for</span> from_node <span class="keyword">in</span> from_nodes:
            <span class="keyword">for</span> to_node <span class="keyword">in</span> to_nodes:
                <span class="comment"># Initialize weight randomly</span>
                self.edges[(from_node, to_node)] = np.random.randn() * 0.1
    
    <span class="keyword">def</span> forward_pass(self, inputs):
        <span class="comment"># Traverse graph in topological order</span>
        <span class="keyword">for</span> node_id <span class="keyword">in</span> self.topology_order:
            <span class="keyword">if</span> node_id.startswith(<span class="string">'input'</span>):
                self.nodes[node_id][<span class="string">'value'</span>] = inputs[node_id]
            <span class="keyword">else</span>:
                <span class="comment"># Compute weighted sum of inputs</span>
                weighted_sum = 0
                <span class="keyword">for</span> (from_node, to_node), weight <span class="keyword">in</span> self.edges.items():
                    <span class="keyword">if</span> to_node == node_id:
                        weighted_sum += self.nodes[from_node][<span class="string">'value'</span>] * weight
                
                <span class="comment"># Apply activation function</span>
                self.nodes[node_id][<span class="string">'value'</span>] = self.activate(
                    weighted_sum, 
                    self.nodes[node_id][<span class="string">'activation'</span>]
                )
    
    <span class="keyword">def</span> backward_pass(self, target):
        <span class="comment"># Traverse graph in reverse topological order</span>
        <span class="keyword">for</span> node_id <span class="keyword">in</span> reversed(self.topology_order):
            <span class="keyword">if</span> node_id.startswith(<span class="string">'output'</span>):
                <span class="comment"># Compute output layer gradients</span>
                predicted = self.nodes[node_id][<span class="string">'value'</span>]
                self.nodes[node_id][<span class="string">'gradient'</span>] = 2 * (predicted - target)
            <span class="keyword">else</span>:
                <span class="comment"># Backpropagate gradients</span>
                gradient = 0
                <span class="keyword">for</span> (from_node, to_node), weight <span class="keyword">in</span> self.edges.items():
                    <span class="keyword">if</span> from_node == node_id:
                        gradient += weight * self.nodes[to_node][<span class="string">'gradient'</span>]
                
                self.nodes[node_id][<span class="string">'gradient'</span>] = gradient
            </div>

            <h3>Graph Neural Networks (GNNs)</h3>
            <p>
                GNNs operate directly on graph-structured data, making them powerful for social networks, molecular analysis, and knowledge graphs. They learn node representations by aggregating information from graph neighborhoods.
            </p>

            <div class="code-block">
<span class="keyword">import</span> torch
<span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn

<span class="keyword">class</span> GraphConvolutionalLayer(nn.Module):
    <span class="string">"""Simple Graph Convolutional Network layer"""</span>
    
    <span class="keyword">def</span> __init__(self, input_dim, output_dim):
        super().__init__()
        self.weight = nn.Parameter(torch.randn(input_dim, output_dim))
        self.bias = nn.Parameter(torch.zeros(output_dim))
    
    <span class="keyword">def</span> forward(self, node_features, adjacency_matrix):
        <span class="comment"># Aggregate neighbor features</span>
        neighbor_features = torch.matmul(adjacency_matrix, node_features)
        
        <span class="comment"># Apply linear transformation</span>
        output = torch.matmul(neighbor_features, self.weight) + self.bias
        
        <span class="keyword">return</span> torch.relu(output)

<span class="keyword">class</span> SimpleGNN(nn.Module):
    <span class="keyword">def</span> __init__(self, input_dim, hidden_dim, output_dim, num_layers=2):
        super().__init__()
        self.layers = nn.ModuleList()
        
        <span class="comment"># Input layer</span>
        self.layers.append(GraphConvolutionalLayer(input_dim, hidden_dim))
        
        <span class="comment"># Hidden layers</span>
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_layers - 2):
            self.layers.append(GraphConvolutionalLayer(hidden_dim, hidden_dim))
        
        <span class="comment"># Output layer</span>
        self.layers.append(GraphConvolutionalLayer(hidden_dim, output_dim))
    
    <span class="keyword">def</span> forward(self, node_features, adjacency_matrix):
        x = node_features
        
        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:
            x = layer(x, adjacency_matrix)
        
        <span class="keyword">return</span> x

<span class="comment"># Example: Node classification on a social network</span>
<span class="comment"># Each node is a person, edges are friendships</span>
<span class="comment"># Goal: Predict person's interests based on friend network</span>

num_nodes = 100
feature_dim = 64
num_classes = 5

<span class="comment"># Node features (e.g., user profile information)</span>
node_features = torch.randn(num_nodes, feature_dim)

<span class="comment"># Adjacency matrix (friendship connections)</span>
adjacency = torch.zeros(num_nodes, num_nodes)
<span class="comment"># Add some random connections...</span>

gnn = SimpleGNN(feature_dim, 32, num_classes)
predictions = gnn(node_features, adjacency)
            </div>

            <h3>Knowledge Graphs and Embeddings</h3>
            <p>
                Knowledge graphs represent entities and relationships as graphs, enabling AI systems to reason about facts and make inferences. Graph embeddings map entities to vector spaces while preserving structural relationships.
            </p>

            <div class="use-case">
                <h5>Real-World Example: Google's Knowledge Graph</h5>
                <p>
                    Google's Knowledge Graph contains billions of entities (people, places, things) connected by relationships. When you search "Who directed Inception?", the system traverses the graph: Inception → directed_by → Christopher Nolan.
                </p>
            </div>

            <div class="code-block">
<span class="keyword">class</span> KnowledgeGraph:
    <span class="string">"""Simple knowledge graph with triple relationships"""</span>
    
    <span class="keyword">def</span> __init__(self):
        self.entities = set()
        self.relations = set()
        self.triples = []  <span class="comment"># (subject, predicate, object)</span>
        self.entity_embeddings = {}
        self.relation_embeddings = {}
    
    <span class="keyword">def</span> add_triple(self, subject, predicate, obj):
        self.entities.update([subject, obj])
        self.relations.add(predicate)
        self.triples.append((subject, predicate, obj))
    
    <span class="keyword">def</span> query_relations(self, entity):
        <span class="string">"""Find all relations involving an entity"""</span>
        relations = []
        <span class="keyword">for</span> s, p, o <span class="keyword">in</span> self.triples:
            <span class="keyword">if</span> s == entity:
                relations.append((p, o, <span class="string">'outgoing'</span>))
            <span class="keyword">elif</span> o == entity:
                relations.append((p, s, <span class="string">'incoming'</span>))
        <span class="keyword">return</span> relations
    
    <span class="keyword">def</span> find_path(self, start_entity, end_entity, max_depth=3):
        <span class="string">"""Find connection path between two entities"""</span>
        <span class="keyword">from</span> collections <span class="keyword">import</span> deque
        
        queue = deque([(start_entity, [start_entity])])
        visited = set([start_entity])
        
        <span class="keyword">while</span> queue:
            entity, path = queue.popleft()
            
            <span class="keyword">if</span> len(path) > max_depth:
                <span class="keyword">continue</span>
            
            <span class="keyword">if</span> entity == end_entity:
                <span class="keyword">return</span> path
            
            relations = self.query_relations(entity)
            <span class="keyword">for</span> predicate, connected_entity, direction <span class="keyword">in</span> relations:
                <span class="keyword">if</span> connected_entity <span class="keyword">not in</span> visited:
                    visited.add(connected_entity)
                    queue.append((connected_entity, path + [connected_entity]))
        
        <span class="keyword">return</span> None

<span class="comment"># Example: Movie knowledge graph</span>
kg = KnowledgeGraph()
kg.add_triple(<span class="string">"Inception"</span>, <span class="string">"directed_by"</span>, <span class="string">"Christopher Nolan"</span>)
kg.add_triple(<span class="string">"Inception"</span>, <span class="string">"stars"</span>, <span class="string">"Leonardo DiCaprio"</span>)
kg.add_triple(<span class="string">"The Dark Knight"</span>, <span class="string">"directed_by"</span>, <span class="string">"Christopher Nolan"</span>)
kg.add_triple(<span class="string">"Titanic"</span>, <span class="string">"stars"</span>, <span class="string">"Leonardo DiCaprio"</span>)

<span class="comment"># Find connection between Inception and Titanic</span>
path = kg.find_path(<span class="string">"Inception"</span>, <span class="string">"Titanic"</span>)
print(path)  <span class="comment"># ['Inception', 'Leonardo DiCaprio', 'Titanic']</span>
            </div>

            <h3>Recommendation Systems Using Graphs</h3>
            <p>
                Graph-based recommendation systems model users, items, and their interactions as a network. They can discover complex patterns and provide more diverse recommendations than traditional collaborative filtering.
            </p>

            <div class="code-block">
<span class="keyword">class</span> BipartiteRecommendationGraph:
    <span class="string">"""Bipartite graph for user-item recommendations"""</span>
    
    <span class="keyword">def</span> __init__(self):
        self.user_item_edges = {}  <span class="comment"># user -> [(item, rating)]</span>
        self.item_user_edges = {}  <span class="comment"># item -> [(user, rating)]</span>
        self.users = set()
        self.items = set()
    
    <span class="keyword">def</span> add_interaction(self, user, item, rating):
        self.users.add(user)
        self.items.add(item)
        
        <span class="keyword">if</span> user <span class="keyword">not in</span> self.user_item_edges:
            self.user_item_edges[user] = []
        self.user_item_edges[user].append((item, rating))
        
        <span class="keyword">if</span> item <span class="keyword">not in</span> self.item_user_edges:
            self.item_user_edges[item] = []
        self.item_user_edges[item].append((user, rating))
    
    <span class="keyword">def</span> user_similarity(self, user1, user2):
        <span class="string">"""Calculate similarity based on common items"""</span>
        items1 = {item <span class="keyword">for</span> item, _ <span class="keyword">in</span> self.user_item_edges.get(user1, [])}
        items2 = {item <span class="keyword">for</span> item, _ <span class="keyword">in</span> self.user_item_edges.get(user2, [])}
        
        common_items = items1.intersection(items2)
        <span class="keyword">if</span> len(common_items) == 0:
            <span class="keyword">return</span> 0
        
        <span class="comment"># Jaccard similarity</span>
        <span class="keyword">return</span> len(common_items) / len(items1.union(items2))
    
    <span class="keyword">def</span> recommend_items(self, target_user, num_recommendations=5):
        <span class="string">"""Graph-based collaborative filtering"""</span>
        <span class="comment"># Find similar users</span>
        user_similarities = []
        <span class="keyword">for</span> user <span class="keyword">in</span> self.users:
            <span class="keyword">if</span> user != target_user:
                sim = self.user_similarity(target_user, user)
                <span class="keyword">if</span> sim > 0:
                    user_similarities.append((user, sim))
        
        <span class="comment"># Sort by similarity</span>
        user_similarities.sort(key=<span class="keyword">lambda</span> x: x[1], reverse=True)
        
        <span class="comment"># Get items from similar users</span>
        target_items = {item <span class="keyword">for</span> item, _ <span class="keyword">in</span> self.user_item_edges.get(target_user, [])}
        recommendations = {}
        
        <span class="keyword">for</span> similar_user, similarity <span class="keyword">in</span> user_similarities[:10]:  <span class="comment"># Top 10 similar users</span>
            <span class="keyword">for</span> item, rating <span class="keyword">in</span> self.user_item_edges.get(similar_user, []):
                <span class="keyword">if</span> item <span class="keyword">not in</span> target_items:  <span class="comment"># New item for target user</span>
                    <span class="keyword">if</span> item <span class="keyword">not in</span> recommendations:
                        recommendations[item] = 0
                    recommendations[item] += similarity * rating
        
        <span class="comment"># Sort recommendations by score</span>
        sorted_recs = sorted(recommendations.items(), key=<span class="keyword">lambda</span> x: x[1], reverse=True)
        <span class="keyword">return</span> sorted_recs[:num_recommendations]

<span class="comment"># Example usage</span>
rec_graph = BipartiteRecommendationGraph()

<span class="comment"># Add user-item interactions</span>
interactions = [
    (<span class="string">"Alice"</span>, <span class="string">"Movie1"</span>, 5), (<span class="string">"Alice"</span>, <span class="string">"Movie2"</span>, 4),
    (<span class="string">"Bob"</span>, <span class="string">"Movie1"</span>, 4), (<span class="string">"Bob"</span>, <span class="string">"Movie3"</span>, 5),
    (<span class="string">"Carol"</span>, <span class="string">"Movie2"</span>, 5), (<span class="string">"Carol"</span>, <span class="string">"Movie3"</span>, 4)
]

<span class="keyword">for</span> user, item, rating <span class="keyword">in</span> interactions:
    rec_graph.add_interaction(user, item, rating)

<span class="comment"># Get recommendations for Alice</span>
recommendations = rec_graph.recommend_items(<span class="string">"Alice"</span>)
print(f<span class="string">"Recommendations for Alice: {recommendations}"</span>)
            </div>
        </div>

        <!-- Problems Section -->
        <div class="section" id="problems">
            <h2><i class="fas fa-puzzle-piece"></i> Real-World Problems & Solutions</h2>
            
            <div class="problem-box">
                <h4>Problem 1: Social Network Influence Propagation</h4>
                <p>
                    <strong>Challenge:</strong> In a social network, you want to identify the minimum set of users to target with marketing to maximize influence spread. This is known as the "Influence Maximization" problem.
                </p>
                
                <div class="problem-solution">
                    <h5>Graph Theory Solution:</h5>
                    <p>Model as a directed graph where users are vertices and follower relationships are edges. Use greedy algorithms with submodular optimization to find influential seed nodes.</p>
                </div>

                <div class="code-block">
<span class="keyword">def</span> greedy_influence_maximization(graph, k, simulation_rounds=1000):
    <span class="string">"""
    Greedy algorithm for influence maximization
    k: number of seed nodes to select
    """</span>
    seed_set = set()
    
    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):
        best_node = None
        best_influence = 0
        
        <span class="comment"># Try each remaining node as next seed</span>
        <span class="keyword">for</span> node <span class="keyword">in</span> graph.vertices:
            <span class="keyword">if</span> node <span class="keyword">not in</span> seed_set:
                <span class="comment"># Simulate influence spread</span>
                current_seeds = seed_set | {node}
                influence = simulate_influence_spread(graph, current_seeds, simulation_rounds)
                
                <span class="keyword">if</span> influence > best_influence:
                    best_influence = influence
                    best_node = node
        
        seed_set.add(best_node)
    
    <span class="keyword">return</span> seed_set

<span class="keyword">def</span> simulate_influence_spread(graph, seed_set, rounds):
    <span class="string">"""Monte Carlo simulation of influence spread"""</span>
    total_influenced = 0
    
    <span class="keyword">for</span> _ <span class="keyword">in</span> range(rounds):
        influenced = set(seed_set)
        queue = list(seed_set)
        
        <span class="keyword">while</span> queue:
            current = queue.pop(0)
            <span class="keyword">for</span> neighbor, influence_prob <span class="keyword">in</span> graph.get_neighbors(current):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> influenced:
                    <span class="keyword">if</span> random.random() < influence_prob:
                        influenced.add(neighbor)
                        queue.append(neighbor)
        
        total_influenced += len(influenced)
    
    <span class="keyword">return</span> total_influenced / rounds
                </div>
            </div>

            <div class="problem-box">
                <h4>Problem 2: Fraud Detection in Financial Networks</h4>
                <p>
                    <strong>Challenge:</strong> Detect fraudulent transactions in a payment network where accounts are connected by transaction history. Fraudulent accounts often form clusters or rings.
                </p>
                
                <div class="problem-solution">
                    <h5>Graph Theory Solution:</h5>
                    <p>Build a transaction graph and use community detection algorithms to find suspicious clusters. Apply graph anomaly detection to identify unusual patterns.</p>
                </div>

                <div class="code-block">
<span class="keyword">class</span> FraudDetectionGraph:
    <span class="keyword">def</span> __init__(self):
        self.transactions = []
        self.account_graph = {}
        self.suspicious_patterns = []
    
    <span class="keyword">def</span> add_transaction(self, from_account, to_account, amount, timestamp):
        self.transactions.append({
            <span class="string">'from'</span>: from_account,
            <span class="string">'to'</span>: to_account,
            <span class="string">'amount'</span>: amount,
            <span class="string">'timestamp'</span>: timestamp
        })
        
        <span class="comment"># Build account connectivity graph</span>
        <span class="keyword">if</span> from_account <span class="keyword">not in</span> self.account_graph:
            self.account_graph[from_account] = []
        self.account_graph[from_account].append(to_account)
    
    <span class="keyword">def</span> detect_circular_transactions(self, max_cycle_length=5):
        <span class="string">"""Detect circular money flows (potential money laundering)"""</span>
        suspicious_cycles = []
        
        <span class="keyword">def</span> dfs_cycle_detection(current, target, path, visited):
            <span class="keyword">if</span> len(path) > max_cycle_length:
                <span class="keyword">return</span>
            
            <span class="keyword">if</span> current == target <span class="keyword">and</span> len(path) > 2:
                suspicious_cycles.append(path.copy())
                <span class="keyword">return</span>
            
            <span class="keyword">for</span> neighbor <span class="keyword">in</span> self.account_graph.get(current, []):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited <span class="keyword">or</span> neighbor == target:
                    visited.add(neighbor)
                    path.append(neighbor)
                    dfs_cycle_detection(neighbor, target, path, visited)
                    path.pop()
                    visited.discard(neighbor)
        
        <span class="keyword">for</span> account <span class="keyword">in</span> self.account_graph:
            dfs_cycle_detection(account, account, [account], {account})
        
        <span class="keyword">return</span> suspicious_cycles
    
    <span class="keyword">def</span> calculate_account_risk_score(self, account):
        <span class="string">"""Calculate risk based on graph features"""</span>
        score = 0
        
        <span class="comment"># High out-degree (many outgoing transactions)</span>
        out_degree = len(self.account_graph.get(account, []))
        score += min(out_degree / 10, 1.0) * 0.3
        
        <span class="comment"># In-degree (many incoming transactions)</span>
        in_degree = sum(1 <span class="keyword">for</span> neighbors <span class="keyword">in</span> self.account_graph.values() 
                       <span class="keyword">if</span> account <span class="keyword">in</span> neighbors)
        score += min(in_degree / 10, 1.0) * 0.3
        
        <span class="comment"># Part of suspicious cycles</span>
        cycles = self.detect_circular_transactions()
        cycle_involvement = sum(1 <span class="keyword">for</span> cycle <span class="keyword">in</span> cycles <span class="keyword">if</span> account <span class="keyword">in</span> cycle)
        score += min(cycle_involvement / 3, 1.0) * 0.4
        
        <span class="keyword">return</span> score
                </div>
            </div>

            <div class="problem-box">
                <h4>Problem 3: Optimal Neural Architecture Search</h4>
                <p>
                    <strong>Challenge:</strong> Automatically find the best neural network architecture for a given task. The search space is enormous, and training each candidate is expensive.
                </p>
                
                <div class="problem-solution">
                    <h5>Graph Theory Solution:</h5>
                    <p>Model neural architectures as directed acyclic graphs. Use graph search algorithms with early stopping and performance prediction to efficiently explore the architecture space.</p>
                </div>

                <div class="code-block">
<span class="keyword">class</span> NeuralArchitectureSearch:
    <span class="keyword">def</span> __init__(self):
        self.search_space = {
            <span class="string">'layers'</span>: [<span class="string">'conv'</span>, <span class="string">'pool'</span>, <span class="string">'dense'</span>, <span class="string">'dropout'</span>],
            <span class="string">'connections'</span>: [<span class="string">'sequential'</span>, <span class="string">'skip'</span>, <span class="string">'residual'</span>],
            <span class="string">'parameters'</span>: {
                <span class="string">'conv_filters'</span>: [32, 64, 128, 256],
                <span class="string">'kernel_sizes'</span>: [3, 5, 7],
                <span class="string">'dense_units'</span>: [64, 128, 256, 512]
            }
        }
        self.evaluated_architectures = {}
    
    <span class="keyword">def</span> generate_random_architecture(self, max_layers=10):
        <span class="string">"""Generate random neural architecture as DAG"""</span>
        architecture = {
            <span class="string">'nodes'</span>: [],
            <span class="string">'edges'</span>: [],
            <span class="string">'performance'</span>: None
        }
        
        num_layers = random.randint(3, max_layers)
        
        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_layers):
            layer_type = random.choice(self.search_space[<span class="string">'layers'</span>])
            
            <span class="keyword">if</span> layer_type == <span class="string">'conv'</span>:
                node = {
                    <span class="string">'id'</span>: i,
                    <span class="string">'type'</span>: <span class="string">'conv'</span>,
                    <span class="string">'filters'</span>: random.choice(self.search_space[<span class="string">'parameters'</span>][<span class="string">'conv_filters'</span>]),
                    <span class="string">'kernel_size'</span>: random.choice(self.search_space[<span class="string">'parameters'</span>][<span class="string">'kernel_sizes'</span>])
                }
            <span class="keyword">elif</span> layer_type == <span class="string">'dense'</span>:
                node = {
                    <span class="string">'id'</span>: i,
                    <span class="string">'type'</span>: <span class="string">'dense'</span>,
                    <span class="string">'units'</span>: random.choice(self.search_space[<span class="string">'parameters'</span>][<span class="string">'dense_units'</span>])
                }
            <span class="keyword">else</span>:
                node = {<span class="string">'id'</span>: i, <span class="string">'type'</span>: layer_type}
            
            architecture[<span class="string">'nodes'</span>].append(node)
            
            <span class="comment"># Add connections (ensure DAG property)</span>
            <span class="keyword">if</span> i > 0:
                <span class="comment"># Sequential connection</span>
                architecture[<span class="string">'edges'</span>].append((i-1, i))
                
                <span class="comment"># Occasional skip connections</span>
                <span class="keyword">if</span> i > 1 <span class="keyword">and</span> random.random() < 0.3:
                    skip_from = random.randint(0, i-2)
                    architecture[<span class="string">'edges'</span>].append((skip_from, i))
        
        <span class="keyword">return</span> architecture
    
    <span class="keyword">def</span> evaluate_architecture(self, architecture):
        <span class="string">"""Evaluate architecture performance (simplified)"""</span>
        <span class="comment"># In practice, this would train the network</span>
        <span class="comment"># Here we use a heuristic based on architecture properties</span>
        
        score = 0.5  <span class="comment"># Base score</span>
        
        <span class="comment"># Prefer moderate depth</span>
        num_layers = len(architecture[<span class="string">'nodes'</span>])
        depth_penalty = abs(num_layers - 6) * 0.05
        score -= depth_penalty
        
        <span class="comment"># Reward skip connections (helps gradient flow)</span>
        skip_connections = sum(1 <span class="keyword">for</span> (from_id, to_id) <span class="keyword">in</span> architecture[<span class="string">'edges'</span>] 
                              <span class="keyword">if</span> to_id - from_id > 1)
        score += skip_connections * 0.1
        
        <span class="comment"># Add some randomness to simulate real performance variation</span>
        score += random.normal(0, 0.1)
        
        <span class="keyword">return</span> max(0, min(1, score))
    
    <span class="keyword">def</span> search_best_architecture(self, num_candidates=100):
        <span class="string">"""Search for best architecture using random search"""</span>
        best_architecture = None
        best_score = 0
        
        <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_candidates):
            arch = self.generate_random_architecture()
            score = self.evaluate_architecture(arch)
            arch[<span class="string">'performance'</span>] = score
            
            <span class="keyword">if</span> score > best_score:
                best_score = score
                best_architecture = arch
        
        <span class="keyword">return</span> best_architecture, best_score
                </div>
            </div>
        </div>

        <!-- Implementation Section -->
        <div class="section" id="implementation">
            <h2><i class="fas fa-code"></i> Complete Python Implementation</h2>
            
            <p>
                Here's a comprehensive graph library that implements all the concepts we've covered, suitable for both learning and practical machine learning applications.
            </p>

            <div class="code-block">
<span class="keyword">import</span> heapq
<span class="keyword">import</span> random
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, deque
<span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict, Set, Tuple, Optional

<span class="keyword">class</span> MLGraph:
    <span class="string">"""
    Comprehensive graph implementation for machine learning applications
    Supports both directed and undirected graphs with weighted edges
    """</span>
    
    <span class="keyword">def</span> __init__(self, directed: bool = False):
        self.directed = directed
        self.adjacency_list: Dict[str, List[Tuple[str, float]]] = defaultdict(list)
        self.vertices: Set[str] = set()
        self.edge_count = 0
    
    <span class="keyword">def</span> add_vertex(self, vertex: str) -> None:
        <span class="string">"""Add a vertex to the graph"""</span>
        self.vertices.add(vertex)
        <span class="keyword">if</span> vertex <span class="keyword">not in</span> self.adjacency_list:
            self.adjacency_list[vertex] = []
    
    <span class="keyword">def</span> add_edge(self, from_vertex: str, to_vertex: str, weight: float = 1.0) -> None:
        <span class="string">"""Add an edge between two vertices"""</span>
        self.add_vertex(from_vertex)
        self.add_vertex(to_vertex)
        
        self.adjacency_list[from_vertex].append((to_vertex, weight))
        self.edge_count += 1
        
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            self.adjacency_list[to_vertex].append((from_vertex, weight))
            self.edge_count += 1
    
    <span class="keyword">def</span> get_neighbors(self, vertex: str) -> List[Tuple[str, float]]:
        <span class="string">"""Get all neighbors of a vertex with edge weights"""</span>
        <span class="keyword">return</span> self.adjacency_list.get(vertex, [])
    
    <span class="keyword">def</span> has_edge(self, from_vertex: str, to_vertex: str) -> bool:
        <span class="string">"""Check if edge exists between two vertices"""</span>
        neighbors = [neighbor <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.get_neighbors(from_vertex)]
        <span class="keyword">return</span> to_vertex <span class="keyword">in</span> neighbors
    
    <span class="keyword">def</span> get_edge_weight(self, from_vertex: str, to_vertex: str) -> Optional[float]:
        <span class="string">"""Get weight of edge between two vertices"""</span>
        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> self.get_neighbors(from_vertex):
            <span class="keyword">if</span> neighbor == to_vertex:
                <span class="keyword">return</span> weight
        <span class="keyword">return</span> None
    
    <span class="comment"># Traversal Algorithms</span>
    
    <span class="keyword">def</span> bfs(self, start_vertex: str) -> Tuple[List[str], Dict[str, int]]:
        <span class="string">"""Breadth-First Search traversal"""</span>
        visited = set()
        queue = deque([start_vertex])
        visit_order = []
        distances = {start_vertex: 0}
        
        <span class="keyword">while</span> queue:
            vertex = queue.popleft()
            
            <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
                visited.add(vertex)
                visit_order.append(vertex)
                
                <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.get_neighbors(vertex):
                    <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                        queue.append(neighbor)
                        <span class="keyword">if</span> neighbor <span class="keyword">not in</span> distances:
                            distances[neighbor] = distances[vertex] + 1
        
        <span class="keyword">return</span> visit_order, distances
    
    <span class="keyword">def</span> dfs(self, start_vertex: str) -> List[str]:
        <span class="string">"""Depth-First Search traversal"""</span>
        visited = set()
        stack = [start_vertex]
        visit_order = []
        
        <span class="keyword">while</span> stack:
            vertex = stack.pop()
            
            <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
                visited.add(vertex)
                visit_order.append(vertex)
                
                <span class="comment"># Add neighbors in reverse order for consistent traversal</span>
                neighbors = [neighbor <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.get_neighbors(vertex)]
                <span class="keyword">for</span> neighbor <span class="keyword">in</span> reversed(neighbors):
                    <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                        stack.append(neighbor)
        
        <span class="keyword">return</span> visit_order
    
    <span class="comment"># Pathfinding Algorithms</span>
    
    <span class="keyword">def</span> dijkstra(self, start_vertex: str) -> Tuple[Dict[str, float], Dict[str, str]]:
        <span class="string">"""Dijkstra's shortest path algorithm"""</span>
        distances = {vertex: float('infinity') <span class="keyword">for</span> vertex <span class="keyword">in</span> self.vertices}
        distances[start_vertex] = 0
        previous = {}
        priority_queue = [(0, start_vertex)]
        visited = set()
        
        <span class="keyword">while</span> priority_queue:
            current_distance, current_vertex = heapq.heappop(priority_queue)
            
            <span class="keyword">if</span> current_vertex <span class="keyword">in</span> visited:
                <span class="keyword">continue</span>
            
            visited.add(current_vertex)
            
            <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> self.get_neighbors(current_vertex):
                distance = current_distance + weight
                
                <span class="keyword">if</span> distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current_vertex
                    heapq.heappush(priority_queue, (distance, neighbor))
        
        <span class="keyword">return</span> distances, previous
    
    <span class="keyword">def</span> shortest_path(self, start: str, end: str) -> Optional[List[str]]:
        <span class="string">"""Find shortest path between two vertices"""</span>
        distances, previous = self.dijkstra(start)
        
        <span class="keyword">if</span> distances[end] == float('infinity'):
            <span class="keyword">return</span> None
        
        path = []
        current = end
        <span class="keyword">while</span> current <span class="keyword">is not</span> None:
            path.append(current)
            current = previous.get(current)
        
        path.reverse()
        <span class="keyword">return</span> path
    
    <span class="comment"># Graph Analysis</span>
    
    <span class="keyword">def</span> is_connected(self) -> bool:
        <span class="string">"""Check if graph is connected (for undirected graphs)"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.vertices:
            <span class="keyword">return</span> True
        
        start_vertex = next(iter(self.vertices))
        visited, _ = self.bfs(start_vertex)
        <span class="keyword">return</span> len(visited) == len(self.vertices)
    
    <span class="keyword">def</span> has_cycle(self) -> bool:
        <span class="string">"""Detect cycles in the graph"""</span>
        <span class="keyword">if</span> self.directed:
            <span class="keyword">return</span> self._has_cycle_directed()
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self._has_cycle_undirected()
    
    <span class="keyword">def</span> _has_cycle_directed(self) -> bool:
        <span class="string">"""Cycle detection for directed graphs using DFS"""</span>
        white = set(self.vertices)  <span class="comment"># Unvisited</span>
        gray = set()                <span class="comment"># Currently processing</span>
        black = set()               <span class="comment"># Fully processed</span>
        
        <span class="keyword">def</span> visit(vertex):
            <span class="keyword">if</span> vertex <span class="keyword">in</span> gray:
                <span class="keyword">return</span> True  <span class="comment"># Back edge found</span>
            <span class="keyword">if</span> vertex <span class="keyword">in</span> black:
                <span class="keyword">return</span> False
            
            white.discard(vertex)
            gray.add(vertex)
            
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.get_neighbors(vertex):
                <span class="keyword">if</span> visit(neighbor):
                    <span class="keyword">return</span> True
            
            gray.discard(vertex)
            black.add(vertex)
            <span class="keyword">return</span> False
        
        <span class="keyword">return</span> any(visit(v) <span class="keyword">for</span> v <span class="keyword">in</span> list(white))
    
    <span class="keyword">def</span> _has_cycle_undirected(self) -> bool:
        <span class="string">"""Cycle detection for undirected graphs using DFS"""</span>
        visited = set()
        
        <span class="keyword">def</span> dfs_cycle(vertex, parent):
            visited.add(vertex)
            
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.get_neighbors(vertex):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    <span class="keyword">if</span> dfs_cycle(neighbor, vertex):
                        <span class="keyword">return</span> True
                <span class="keyword">elif</span> neighbor != parent:
                    <span class="keyword">return</span> True  <span class="comment"># Back edge found</span>
            
            <span class="keyword">return</span> False
        
        <span class="keyword">for</span> vertex <span class="keyword">in</span> self.vertices:
            <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
                <span class="keyword">if</span> dfs_cycle(vertex, None):
                    <span class="keyword">return</span> True
        
        <span class="keyword">return</span> False
    
    <span class="keyword">def</span> topological_sort(self) -> Optional[List[str]]:
        <span class="string">"""Topological sorting for directed acyclic graphs"""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            <span class="keyword">raise</span> ValueError(<span class="string">"Topological sort only applies to directed graphs"</span>)
        
        <span class="keyword">if</span> self.has_cycle():
            <span class="keyword">return</span> None  <span class="comment"># Cannot sort cyclic graph</span>
        
        visited = set()
        stack = []
        
        <span class="keyword">def</span> dfs_topo(vertex):
            visited.add(vertex)
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> self.get_neighbors(vertex):
                <span class="keyword">if</span> neighbor <span class="keyword">not in</span> visited:
                    dfs_topo(neighbor)
            stack.append(vertex)
        
        <span class="keyword">for</span> vertex <span class="keyword">in</span> self.vertices:
            <span class="keyword">if</span> vertex <span class="keyword">not in</span> visited:
                dfs_topo(vertex)
        
        <span class="keyword">return</span> stack[::-1]  <span class="comment"># Reverse for topological order</span>
    
    <span class="keyword">def</span> graph_statistics(self) -> Dict:
        <span class="string">"""Calculate various graph statistics"""</span>
        stats = {
            <span class="string">'num_vertices'</span>: len(self.vertices),
            <span class="string">'num_edges'</span>: self.edge_count,
            <span class="string">'is_directed'</span>: self.directed,
            <span class="string">'is_connected'</span>: self.is_connected() <span class="keyword">if</span> <span class="keyword">not</span> self.directed <span class="keyword">else</span> None,
            <span class="string">'has_cycle'</span>: self.has_cycle(),
            <span class="string">'density'</span>: self._calculate_density()
        }
        
        <span class="comment"># Degree statistics</span>
        degrees = [len(self.get_neighbors(v)) <span class="keyword">for</span> v <span class="keyword">in</span> self.vertices]
        <span class="keyword">if</span> degrees:
            stats[<span class="string">'avg_degree'</span>] = sum(degrees) / len(degrees)
            stats[<span class="string">'max_degree'</span>] = max(degrees)
            stats[<span class="string">'min_degree'</span>] = min(degrees)
        
        <span class="keyword">return</span> stats
    
    <span class="keyword">def</span> _calculate_density(self) -> float:
        <span class="string">"""Calculate graph density"""</span>
        n = len(self.vertices)
        <span class="keyword">if</span> n < 2:
            <span class="keyword">return</span> 0.0
        
        max_edges = n * (n - 1)
        <span class="keyword">if</span> <span class="keyword">not</span> self.directed:
            max_edges //= 2
        
        <span class="keyword">return</span> self.edge_count / max_edges <span class="keyword">if</span> max_edges > 0 <span class="keyword">else</span> 0.0

<span class="comment"># Example usage demonstrating all features</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Create a directed graph for neural network representation</span>
    nn_graph = MLGraph(directed=True)
    
    <span class="comment"># Add layers</span>
    layers = [<span class="string">'input'</span>, <span class="string">'hidden1'</span>, <span class="string">'hidden2'</span>, <span class="string">'output'</span>]
    <span class="keyword">for</span> layer <span class="keyword">in</span> layers:
        nn_graph.add_vertex(layer)
    
    <span class="comment"># Add connections with weights</span>
    nn_graph.add_edge(<span class="string">'input'</span>, <span class="string">'hidden1'</span>, 0.8)
    nn_graph.add_edge(<span class="string">'hidden1'</span>, <span class="string">'hidden2'</span>, 0.6)
    nn_graph.add_edge(<span class="string">'hidden2'</span>, <span class="string">'output'</span>, 0.9)
    nn_graph.add_edge(<span class="string">'input'</span>, <span class="string">'hidden2'</span>, 0.3)  <span class="comment"># Skip connection</span>
    
    <span class="comment"># Analyze the network</span>
    print(<span class="string">"Neural Network Graph Analysis:"</span>)
    print(f<span class="string">"Topological order: {nn_graph.topological_sort()}"</span>)
    print(f<span class="string">"Has cycles: {nn_graph.has_cycle()}"</span>)
    print(f<span class="string">"Statistics: {nn_graph.graph_statistics()}"</span>)
    
    <span class="comment"># Shortest path from input to output</span>
    path = nn_graph.shortest_path(<span class="string">'input'</span>, <span class="string">'output'</span>)
    print(f<span class="string">"Shortest path from input to output: {path}"</span>)
            </div>

            <div class="complexity-box">
                <h4>Implementation Performance Summary</h4>
                <table style="width: 100%; color: #f5f5f5;">
                    <tr style="border-bottom: 1px solid #cc785c;">
                        <th>Operation</th>
                        <th>Time Complexity</th>
                        <th>Space Complexity</th>
                        <th>Use Case</th>
                    </tr>
                    <tr>
                        <td>Add Vertex/Edge</td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                        <td>Graph construction</td>
                    </tr>
                    <tr>
                        <td>BFS/DFS</td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Graph traversal</td>
                    </tr>
                    <tr>
                        <td>Dijkstra's</td>
                        <td>O((V + E) log V)</td>
                        <td>O(V)</td>
                        <td>Shortest paths</td>
                    </tr>
                    <tr>
                        <td>Cycle Detection</td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Graph validation</td>
                    </tr>
                    <tr>
                        <td>Topological Sort</td>
                        <td>O(V + E)</td>
                        <td>O(V)</td>
                        <td>Dependency ordering</td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="contact-info">
            <h3 style="color: #cc785c; margin-bottom: 1rem;"><i class="fas fa-graduation-cap"></i> Mastering Graph Theory for ML</h3>
            <p>
                Graph theory provides the mathematical foundation for understanding complex relationships in data, neural network architectures, and algorithmic problem-solving. These concepts are essential for advanced machine learning applications.
            </p>
            <div style="margin-top: 1.5rem;">
                <a href="machine-learning.html" style="color: #cc785c; text-decoration: none; border: 1px solid #cc785c; padding: 0.75rem 1.5rem; border-radius: 5px; transition: all 0.3s ease;">
                    <i class="fas fa-arrow-left"></i> Back to ML Topics
                </a>
            </div>
        </div>
    </div>

    <script>
        let stepMode = false;
        let currentAlgorithm = null;
        let algorithmState = null;

        // Graph Types Visualization
        function showUndirected() {
            document.getElementById('undirected-graph').style.display = 'block';
            document.getElementById('directed-graph').style.display = 'none';
            document.getElementById('graph-explanation').innerHTML = 
                '<strong>Undirected Graph:</strong> Edges have no direction. Represents symmetric relationships like friendship networks or physical connections.';
        }

        function showDirected() {
            document.getElementById('undirected-graph').style.display = 'none';
            document.getElementById('directed-graph').style.display = 'block';
            document.getElementById('graph-explanation').innerHTML = 
                '<strong>Directed Graph:</strong> Edges have direction, representing asymmetric relationships like web links, neural connections, or dependencies.';
        }

        function showWeighted() {
            document.getElementById('graph-explanation').innerHTML = 
                '<strong>Weighted Graph:</strong> Edges have associated weights representing costs, distances, similarities, or connection strengths. Essential for optimization and pathfinding.';
        }

        function showComplete() {
            document.getElementById('graph-explanation').innerHTML = 
                '<strong>Complete Graph:</strong> Every vertex is connected to every other vertex. Useful for analyzing worst-case scenarios and maximum connectivity.';
        }

        // Traversal Animation
        function resetTraversal() {
            for (let i = 1; i <= 10; i++) {
                const node = document.getElementById(`node-${i}`);
                if (node) {
                    node.classList.remove('visited-node', 'current-node');
                }
            }
            
            document.getElementById('current-algorithm').textContent = 'Choose an algorithm above';
            document.getElementById('visit-order').textContent = '-';
            document.getElementById('data-structure').textContent = '-';
            document.getElementById('current-step').textContent = 'Ready to start';
            
            currentAlgorithm = null;
            algorithmState = null;
        }

        async function animateBFS() {
            resetTraversal();
            currentAlgorithm = 'BFS';
            
            document.getElementById('current-algorithm').textContent = 'Breadth-First Search';
            document.getElementById('data-structure').textContent = 'Queue (FIFO)';
            
            const bfsOrder = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            let visitOrder = [];
            
            document.getElementById('bfs-btn').disabled = true;
            document.getElementById('dfs-btn').disabled = true;
            
            for (let i = 0; i < bfsOrder.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 800));
                
                const nodeId = `node-${bfsOrder[i]}`;
                const node = document.getElementById(nodeId);
                if (node) {
                    node.classList.add('visited-node');
                    visitOrder.push(bfsOrder[i]);
                    
                    document.getElementById('visit-order').textContent = visitOrder.join(' → ');
                    document.getElementById('current-step').textContent = `Visiting node ${bfsOrder[i]} (level-by-level exploration)`;
                }
            }
            
            document.getElementById('current-step').textContent = 'BFS completed - shortest paths found!';
            document.getElementById('bfs-btn').disabled = false;
            document.getElementById('dfs-btn').disabled = false;
        }

        async function animateDFS() {
            resetTraversal();
            currentAlgorithm = 'DFS';
            
            document.getElementById('current-algorithm').textContent = 'Depth-First Search';
            document.getElementById('data-structure').textContent = 'Stack (LIFO)';
            
            const dfsOrder = [1, 2, 4, 8, 9, 5, 10, 3, 6, 7];
            let visitOrder = [];
            
            document.getElementById('bfs-btn').disabled = true;
            document.getElementById('dfs-btn').disabled = true;
            
            for (let i = 0; i < dfsOrder.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 800));
                
                const nodeId = `node-${dfsOrder[i]}`;
                const node = document.getElementById(nodeId);
                if (node) {
                    node.classList.add('visited-node');
                    visitOrder.push(dfsOrder[i]);
                    
                    document.getElementById('visit-order').textContent = visitOrder.join(' → ');
                    document.getElementById('current-step').textContent = `Visiting node ${dfsOrder[i]} (depth-first exploration)`;
                }
            }
            
            document.getElementById('current-step').textContent = 'DFS completed - full exploration done!';
            document.getElementById('bfs-btn').disabled = false;
            document.getElementById('dfs-btn').disabled = false;
        }

        // Dijkstra's Algorithm Animation
        function resetDijkstra() {
            const nodes = ['s', 'a', 'b', 'c', 'd', 'e', 'f', 't'];
            nodes.forEach(node => {
                const nodeElement = document.getElementById(`d-node-${node}`);
                if (nodeElement) {
                    nodeElement.classList.remove('visited-node', 'current-node');
                }
                
                const distElement = document.getElementById(`dist-${node}`);
                if (distElement) {
                    if (node === 's') {
                        distElement.textContent = '0';
                    } else {
                        distElement.textContent = '∞';
                    }
                }
            });
            
            // Reset edge highlighting
            for (let i = 1; i <= 11; i++) {
                const edge = document.getElementById(`d-edge-${i}`);
                if (edge) edge.classList.remove('path-highlight');
            }
            
            document.getElementById('current-node').textContent = 'S (Start)';
            document.getElementById('priority-queue').textContent = '[(0, S)]';
            document.getElementById('shortest-path').textContent = 'Not found yet';
            document.getElementById('total-distance').textContent = '-';
        }

        async function runDijkstra() {
            resetDijkstra();
            
            document.getElementById('dijkstra-btn').disabled = true;
            
            const steps = [
                {node: 's', dist: 0, visited: true, queue: '[(0, S)]'},
                {node: 'b', dist: 2, update: true, queue: '[(2, B), (4, A)]'},
                {node: 'b', dist: 2, visited: true, queue: '[(4, A)]'},
                {node: 'd', dist: 3, update: true, queue: '[(4, A), (3, D)]'},
                {node: 'd', dist: 3, visited: true, queue: '[(4, A)]'},
                {node: 'a', dist: 4, visited: true, queue: '[]'},
                {node: 'c', dist: 7, update: true, queue: '[(7, C)]'},
                {node: 'e', dist: 6, update: true, queue: '[(6, E), (7, C)]'},
                {node: 'e', dist: 6, visited: true, queue: '[(7, C)]'},
                {node: 't', dist: 8, update: true, queue: '[(7, C), (8, T)]'},
                {node: 't', dist: 8, visited: true, final: true}
            ];
            
            for (const step of steps) {
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                if (step.update) {
                    const distElement = document.getElementById(`dist-${step.node}`);
                    if (distElement) {
                        distElement.textContent = step.dist;
                    }
                }
                
                if (step.visited) {
                    const nodeElement = document.getElementById(`d-node-${step.node}`);
                    if (nodeElement) {
                        nodeElement.classList.add('visited-node');
                    }
                }
                
                document.getElementById('current-node').textContent = step.node.toUpperCase();
                if (step.queue) {
                    document.getElementById('priority-queue').textContent = step.queue;
                }
                
                if (step.final) {
                    // Highlight shortest path: S → B → D → E → T
                    const pathEdges = ['d-edge-sb', 'd-edge-bd', 'd-edge-de', 'd-edge-et'];
                    pathEdges.forEach(edgeId => {
                        const edge = document.getElementById(edgeId);
                        if (edge) edge.classList.add('path-highlight');
                    });
                    
                    document.getElementById('shortest-path').textContent = 'S → B → D → E → T';
                    document.getElementById('total-distance').textContent = '8';
                }
            }
            
            document.getElementById('dijkstra-btn').disabled = false;
        }

        // Initialize with undirected graph
        showUndirected();
    </script>
</body>
</html>